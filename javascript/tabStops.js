/**
 * Utility module for handling tabstops tokens generated by Zen Coding's 
 * "Expand Abbreviation" action. The main <code>extract</code> method will take
 * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops 
 * occurrences, replace them with tokens suitable for your editor of choice and 
 * return object with processed text and list of found tabstops and their ranges.
 * For sake of portability (Objective-C/Java) the tabstops list is a plain 
 * sorted array with plain objects.
 * 
 * Placeholders with the same are meant to be <i>linked</i> in your editor.
 * @param {Function} require
 * @param {Underscore} _  
 */
zen_coding.define('tabStops', function(require, _) {
	/**
	 * Global placeholder value, automatically incremented by 
	 * <code>variablesResolver()</code> function
	 */
	var startPlaceholderNum = 100;
	
	var defaultOptions = {
		replaceCarets: true,
		escape: function(ch) {
			return ch;
		}
	};
	
	return {
		/**
		 * Main function that looks for a tabstops in provided <code>text</code>
		 * and returns a processed version of <code>text</code> and list of
		 * tabstops found.
		 * @param {String} text Text to process
		 * @param {Object} options List of processor options:<br>
		 * 
		 * <b>replaceCarets</b> : <code>Boolean</code> — replace all default
		 * caret placeholders (like <i>{%::zen-caret::%}</i>) with <i>${0:caret}</i><br>
		 * 
		 * <b>escape</b> : <code>Function</code> — function that handle escaped
		 * characters (mostly '$'). By default, it returns the character itself 
		 * to be displayed as is in output, but sometimes you will use 
		 * <code>extract</code> method as intermediate solution for further 
		 * processing and want to keep character escaped. Thus, you should override
		 * <code>escape</code> method to return escaped symbol (e.g. '\\$')<br>
		 * 
		 * <b>tabstop</b> : <code>Function</code> – a tabstop handler. Receives 
		 * a single argument – an object describing token: its position, number 
		 * group, placeholder and token itself. Should return a replacement 
		 * string that will appear in final output
		 * 
		 * @returns {Object} Object with processed <code>text</code> property
		 * and array of <code>tabstops</code> found
		 * @memberOf zen_coding.tabStops
		 */
		extract: function(text, options) {
			// prepare defaults
			var utils = require('utils');
			var placeholders = {};
			var marks = [];
			
			options = _.extend({}, defaultOptions, options, {
				tabstop: function(data) {
					var ret = '';
					if (data.placeholder == 'cursor') {
						marks.push({
							start: data.start,
							end: data.start + data.token.length,
							group: 'carets',
							value: ''
						});
					} else {
						// unify placeholder value for single group
						if ('placeholder' in data)
							placeholders[data.group] = data.placeholder;
						
						if (data.group in placeholders)
							ret = placeholders[data.group];
						
						marks.push({
							start: data.start,
							end: data.start + data.token.length,
							group: data.group,
							value: ret
						});
					}
					
					return data.token;
				}
			});
			
			text = utils.escapeText(text);
			if (options.replaceCarets) {
				text = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');
			}
			
			// locate tabstops and unify group's placeholders
			text = this.processText(text, options);
			
			// now, replace all tabstops with placeholders
			var tabStops = [], lastIx = 0;
			
			/** @type MutableString */
			var buf = utils.stringBuilder();
			
			_.each(marks, function(mark) {
				buf.append(text.substring(lastIx, mark.start));
				
				var ph = '';
				if (mark.group != 'carets' && mark.group in placeholders)
					ph = placeholders[mark.group];
				
				tabStops.push({
					group: mark.group,
					start: buf.length,
					end:  buf.length + ph.length
				});
				
				buf.append(ph);
				lastIx = mark.end;
			});
			
			buf.append(text.substring(lastIx));
			
			// sort tabstops by their positions
			tabStops.sort(function(a, b) {
				return a.start - b.start;
			});
			
			return {
				text: buf.toString(),
				tabstops: tabStops
			};
		},
		
		/**
		 * Text processing routine. Locates escaped characters and tabstops and
		 * replaces them with values returned by handlers defined in 
		 * <code>options</code>
		 * @param {String} text
		 * @param {Object} options See <code>extract</code> method options 
		 * description
		 * @returns {String}
		 */
		processText: function(text, options) {
			var utils = require('utils');
			var strBuilder = utils.stringBuilder();
			
			// provide safe defaults
			options = _.extend({}, defaultOptions, {
				tabstop: function(data) {
					return data.token;
				}
			}, options);
			
			var i = 0, il = text.length, startIx, tokenStart;
				
			var nextWhile = function(ix, fn) {
				while (ix < il) if (!fn(text.charAt(ix++))) break;
				return ix - 1;
			};
			
			
			while (i < il) {
				var ch = text.charAt(i);
				if (ch == '\\' && i + 1 < il) {
					// handle escaped character
					strBuilder.append(options.escape(text.charAt(i + 1)));
					i += 2;
					continue;
				} else if (ch == '$') {
					// looks like a tabstop
					var nextCh = text.charAt(i + 1) || '';
					
					// remember token start position
					tokenStart = i;
					if (utils.isNumeric(nextCh)) {
						// $N placeholder
						startIx = i + 1;
						i = nextWhile(startIx, utils.isNumeric);
						if (startIx < i) {
							strBuilder.append(options.tabstop({
								start: strBuilder.length, 
								group: text.substring(startIx, i),
								token: text.substring(tokenStart, i)
							}));
							continue;
						}
					} else if (nextCh == '{') {
						// ${N:value} or ${N} placeholder
						var braceCount = 1;
						startIx = i + 2;
						i = nextWhile(startIx, utils.isNumeric);
						
						if (i > startIx) {
							if (text.charAt(i) == '}') {
								strBuilder.append(options.tabstop({
									start: strBuilder.length, 
									group: text.substring(startIx, i),
									token: text.substring(tokenStart, i + 1)
								}));
								
								i++; // handle closing brace
								continue;
							} else if (text.charAt(i) == ':') {
								var valStart = i + 2;
								i = nextWhile(valStart, function(c) {
									if (c == '{') braceCount++;
									else if (c == '}') braceCount--;
									return !!braceCount;
								});
								
								strBuilder.append(options.tabstop({
									start: strBuilder.length, 
									group: text.substring(startIx, valStart - 2), 
									placeholder: text.substring(valStart - 1, i),
									token: text.substring(tokenStart, i + 1)
								}));
								
								i++; // handle closing brace
								continue;
							}
						}
					}
					i = tokenStart;
				}
				
				// push current character to stack
				strBuilder.append(ch);
				i++;
			}
			
			return strBuilder.toString();
		},
		
		/**
		 * Upgrades tabstops in zen node in order to prevent naming conflicts
		 * @param {ZenNode} node
		 * @param {Number} offset Tab index offset
		 * @returns {Number} Maximum tabstop index in element
		 */
		upgrade: function(node, offset) {
			var maxNum = 0;
			var options = {
				escape: function(ch) {
					return '\\' + ch;
				},
				tabstop: function(data) {
					var group = parseInt(data.group);
					if (group > maxNum) maxNum = group;
						
					if (data.placeholder)
						return '${' + (group + offset) + ':' + data.placeholder + '}';
					else
						return '$' + (group + offset);
				}
			};
			
			_.each(['start', 'end', 'content'], function(p) {
				node[p] = this.processText(node[p], options);
			}, this);
			
			return maxNum;
		},
		
		/**
		 * Helper function that produces a callback function for 
		 * <code>replaceVariables()</code> method from {@link zen_coding.utils}
		 * module. This callback will replace variable definitions (like 
		 * ${var_name}) with their value defined in <i>resource</i> module,
		 * or outputs tabstop with variable name otherwise.
		 * @param {ZenNode} node Context node
		 * @returns {Function}
		 */
		variablesResolver: function(node) {
			var placeholderMemo = {};
			var res = require('resources');
			return function(str, varName) {
				var attr = node.getAttribute(varName);
				if (attr !== null)
					return attr;
				
				var varValue = res.getVariable(varName);
				if (varValue)
					return varValue;
				
				// output as placeholder
				if (!placeholderMemo[varName])
					placeholderMemo[varName] = startPlaceholderNum++;
					
				return '${' + placeholderMemo[varName] + ':' + varName + '}';
			};
		},
		
		resetPlaceholderCounter: function() {
			startPlaceholderNum = 100;
		}
	};
});