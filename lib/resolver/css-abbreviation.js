/**
 * CSS abbreviation parser: takes abbreviation token and transforms it into 
 * an object with CSS property and value as well as some other data
 * about final CSS property representation.
 *
 * This object can be used to produce final CSS snippet for abbreviation
 */
if (typeof module === 'object' && typeof define !== 'function') {
	var define = function (factory) {
		module.exports = factory(require, exports, module);
	};
}

define(function(require, exports, module) {
	var stringStream = require('../assets/stringStream');
	var utils = require('../utils/common');
	var prefs = require('../assets/preferences');
	var resources = require('../assets/resources');

	var reValueEdge = /[#\$]|\-?[\d\.]/;
	var reNum = /^\-?[\d\.]/;

	prefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', 
			'The list of properties whose values ​​must not contain units.');
	
	prefs.define('css.intUnit', 'px', 'Default unit for integer values');
	prefs.define('css.floatUnit', 'em', 'Default unit for float values');
	
	prefs.define('css.keywords', 'auto, inherit, all', 
			'A comma-separated list of valid keywords that can be used in CSS abbreviations.');
	
	prefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', 
			'A comma-separated list of keyword aliases, used in CSS abbreviation. '
			+ 'Each alias should be defined as <code>alias:keyword_name</code>.');
	
	prefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', 
			'A comma-separated list of unit aliases, used in CSS abbreviation. '
			+ 'Each alias should be defined as <code>alias:unit_value</code>.');
	
	prefs.define('css.color.short', true, 
			'Should color values like <code>#ffffff</code> be shortened to '
			+ '<code>#fff</code> after abbreviation with color was expanded.');
	
	prefs.define('css.color.case', 'keep', 
			'Letter case of color values generated by abbreviations with color '
			+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '
			+ '<code>lower</code> and <code>keep</code>.');
	
	prefs.define('css.fuzzySearch', true, 
			'Enable fuzzy search among CSS snippet names. When enabled, every ' 
			+ '<em>unknown</em> snippet will be scored against available snippet '
			+ 'names (not values or CSS properties!). The match with best score '
			+ 'will be used to resolve snippet value. For example, with this ' 
			+ 'preference enabled, the following abbreviations are equal: '
			+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '
			+ '<code>oh</code>');
	
	prefs.define('css.fuzzySearchMinScore', 0.3, 
			'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' 
			+ 'achive. Lower values may produce many false-positive matches, '
			+ 'higher values may reduce possible matches.');

	function matchEdge(str) {
		return reValueEdge.exec(str);
	}

	function isNum(ch) {
		return reNum.test(ch);
	}

	function last(arr) {
		return arr[arr.length - 1];
	}

	function makeOptions(opt) {
		return utils.extend({
			colorCase: prefs.get('css.color.case'),
			colorShort: prefs.get('css.color.short'),
			keywords: prefs.getArray('css.keywords'),
			keywordAliases: prefs.getDict('css.keywordAliases'),
			fuzzySearch: prefs.get('css.fuzzySearch'),
			fuzzyScore: parseFloat(prefs.get('css.fuzzySearchMinScore')),
			unitless: prefs.getArray('css.unitlessProperties'),
			unitAliases: prefs.getDict('css.unitAliases'),
			floatUnit: prefs.get('css.floatUnit'),
			intUnit: prefs.get('css.intUnit')
		}, opt);
	}

	function normalizeHexColor(value, options) {
		var hex = value.replace(/^#+/, '') || '0';
		if (hex.toLowerCase() === 't') {
			return 'transparent';
		}

		var opacity = '';
		hex = hex.replace(/\.(\d+)$/, function(str) {
			opacity = '0' + str;
			return '';
		});
		
		var repeat = utils.repeatString;
		var color = null;
		switch (hex.length) {
			case 1:
				color = repeat(hex, 6);
				break;
			case 2:
				color = repeat(hex, 3);
				break;
			case 3:
				color = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
				break;
			case 4:
				color = hex + hex.substr(0, 2);
				break;
			case 5:
				color = hex + hex.charAt(0);
				break;
			default:
				color = hex.substr(0, 6);
		}

		if (opacity) {
			return toRGBA(color, opacity);
		}
		
		// color must be shortened?
		if (options.colorShort) {
			var p = color.split('');
			if (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {
				color = p[0] + p[2] + p[4];
			}
		}
		
		// should transform case?
		switch (options.colorCase) {
			case 'upper':
				color = color.toUpperCase();
				break;
			case 'lower':
				color = color.toLowerCase();
				break;
		}
		
		return '#' + color;
	}

	/**
	 * Transforms HEX color definition into RGBA one
	 * @param  {String} color   HEX color, 6 characters
	 * @param  {String} opacity Opacity value
	 * @return {String}
	 */
	function toRGBA(color, opacity) {
		var r = parseInt(color.substr(0, 2), 16);
		var g = parseInt(color.substr(2, 2), 16);
		var b = parseInt(color.substr(4, 2), 16);

		return 'rgba(' + [r, g, b, opacity].join(', ') + ')';
	}

	function normalizeNumber(value, property, options) {
		return value.replace(/^(\-?[0-9\.]+)([a-z]*)$/, function(str, val, unit) {
			if (!unit && (val === '0' || ~options.unitless.indexOf(property))) {
				return val;
			}
			
			if (!unit) {
				return val.replace(/\.$/, '') + (~val.indexOf('.') ? options.floatUnit : options.intUnit);
			}

			if (unit in options.unitAliases) {
				unit = options.unitAliases[unit];
			}
			
			return val + unit;
		});
	}

	/**
	 * Check if provided snippet contains only one CSS property and value.
	 * @param {String} snippet
	 * @returns {Boolean}
	 */
	function isSingleProperty(snippet) {
		snippet = snippet.trim();
		
		// check if it doesn't contain a comment and a newline
		if (/\/\*|\n|\r/.test(snippet)) {
			return false;
		}
		
		// check if it's a valid snippet definition
		if (!/^[a-z0-9\-]+\s*\:/i.test(snippet)) {
			return false;
		}
		
		return snippet.replace(/\$\{.+?\}/g, '').split(':').length === 2;
	}

	/**
	 * Splits given abbreviation into CSS property tokens
	 * @param  {String} abbr
	 * @return {Object}
	 */
	return {
		split: function(abbr, options) {
			options = makeOptions(options);
			var important = /\!$/.test(abbr);
			if (important) {
				abbr = abbr.substr(0, abbr.length - 1);
			}

			// split abbreviation into a name and value
			var name = abbr, value;
			var m = matchEdge(abbr);
			if (m) {
				name = abbr.substr(0, m.index);
				value = abbr.substr(m.index);
			}

			var valueTokens = this.parseValue(value, options);
			return {
				name: name,
				value: valueTokens.join(' '),
				tokens: valueTokens,
				important: important
			};
		},

		/**
		 * Parses abbreviation into an object with CSS property name
		 * and value. The property name contains resolved name
		 * found in resources.
		 * @param  {String} abbr Abbreviation to parse
		 * @return {Object}
		 */
		parse: function(abbr, syntax, options) {
			syntax = syntax || 'css';
			options = makeOptions(options);
			var defaultValue = null;
			var property = this.split(abbr, options);


			if (!property.name) {
				return null;
			}

			var snippet = resources.find(property.name, syntax, options);
			if (!snippet) {
				// No snippet found for current name. It’s possible
				// because snippet name may contain keyword tokens, 
				// for example `m-a`, which means `margin: auto`.
				// Try to extract tokens from name
				var parts = property.name.split('-');
				var nameParts, kw;
				while (kw = parts.pop()) {
					if (kw in options.keywordAliases || ~options.keywords.indexOf(kw)) {
						property.tokens.unshift(kw);
					} else {
						parts.push(kw);
						break;
					}
				}
				property.name = parts.join('-');
				snippet = resources.find(property.name, syntax, options);
			}

			if (snippet) {
				if (typeof snippet === 'object') {
					snippet = snippet.data;
				}

				if (isSingleProperty(snippet)) {
					var snippetParts = this.splitSnippet(snippet);
					property.name = snippetParts.name;
					if (snippetParts.value) {
						defaultValue = snippetParts.value.replace(/;\s*$/, '');
					}
				}
			}

			// normalize value tokens: 
			// replace keyword aliases in with keywords, 
			// add units to numeric values
			property.tokens = property.tokens.map(function(token) {
				return this.normalizeValue(token.trim(), property.name, options);
			}, this);

			if (!property.tokens.length && defaultValue) {
				property.tokens.push(defaultValue);
			}

			property.value = property.tokens.join(' ');
			return property;
		},

		/**
		 * Resolves value part, extracted from abbreviation, into a list
		 * of value tokens
		 * @param  {String} str Value part, extracted from abreviation
		 * @return {Array}
		 */
		parseValue: function(str, options) {
			if (!str) {
				return [];
			}
			
			var stream = stringStream.create(str);
			var reNum = /[0-9\.]/;
			var reNotNum = /[^0-9\.\-#]/;
			var reVar = /[\$@]/;

			var values = [], prev, cur;
			var isVar = reVar.test(str.charAt(0));

			while (prev = stream.next()) {
				cur = stream.peek();
				if (prev === '#') {
					stream.match(/^[0-9a-ft]{0,6}(\.\d+)?/i, true);
					values.push(stream.current());
					stream.start = stream.pos;
					continue;
				}

				// split string either on separator ($, #, -)
				// or right between number and not number, e.g. 10px20px
				if (/[\$#\-]/.test(cur) || (reNum.test(cur) && reNotNum.test(prev) && !isVar)) {
					values.push(stream.current());
					isVar = reVar.test(cur);

					if (cur !== '#' && cur !== '$' && !reNum.test(cur)) {
						stream.next();
					}
					// test edge case: negative number right after non-number
					if (cur === '-' && reNum.test(stream.peek()) && reNotNum.test(prev)) {
						stream.backUp(1);
					}
					stream.start = stream.pos;
				}
			}

			values.push(stream.current());

			return values.filter(function(item) {
				return !!item;
			});
		},

		/**
		 * Normalizes abbreviated value to final CSS one
		 * @param {String} value
		 * @returns {String}
		 */
		normalizeValue: function(value, property, options) {
			options = options || makeOptions();

			if (options.keywordAliases && value in options.keywordAliases) {
				return options.keywordAliases[value];
			}
			
			if (value.charAt(0) === '-' && !/^\-[\.\d]/.test(value)) {
				value = value.replace(/^\-+/, '');
			}
			
			var ch = value.charAt(0);
			if (ch === '#') {
				return normalizeHexColor(value, options);
			}

			if (ch === '$') {
				return utils.escapeText(value);
			}

			return normalizeNumber(value, property, options);
		},

		/**
		 * Split snippet into a CSS property-value pair
		 * @param {String} snippet
		 */
		splitSnippet: function(snippet) {
			var name = snippet.trim().replace(/;$/, '');
			var value = null;
			if (~name.indexOf(':')) {
				var pair = snippet.split(':');
				name = pair.shift().trim();
				// replace ${0} tabstop to produce valid vendor-prefixed values
				// where possible
				value = pair.join(':').trim().replace(/^(\$\{0\}|\$0)(\s*;?)$/, '${1}$2');
			}

			return {
				name: name,
				value: value
			};
		}
	};
});